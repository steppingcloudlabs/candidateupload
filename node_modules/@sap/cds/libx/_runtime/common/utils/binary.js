// convert the standard base64 encoding to the URL-safe variant
const toBase64url = value => {
  const buffer = Buffer.isBuffer(value) ? value : Buffer.from(value, 'base64')
  const base64url = buffer.toString('base64url')
  // Buffer base64url encoding does not have padding by default -> add it
  return base64url.padEnd(Math.ceil(base64url.length / 4) * 4, '=')
}

const normalizeBase64string = value => {
  if (typeof value !== 'string') return value
  // add last byte(s) and '=' padding in case of shortend base64
  return Buffer.from(value, 'base64').toString('base64')
}

// REVISIT: The function is only used in okra.
// To be removed with the function normalizeBase64string above
const isInvalidBase64string = value => {
  if (Buffer.isBuffer(value)) return // ok

  // convert to standard base64 string; let it crash if typeof value !== 'string'
  const base64value = value.replace(/_/g, '/').replace(/-/g, '+')
  const normalized = normalizeBase64string(value)

  // example of invalid base64 string --> 'WTGTdDsD/k21LnFRb+uNcAi=' <-- '...i=' must be '...g='
  // see https://datatracker.ietf.org/doc/html/rfc4648#section-4
  if (base64value.replace(/=/g, '') !== normalized.replace(/=/g, '')) return true
  return base64value.length > normalized.length
}

module.exports = {
  normalizeBase64string,
  isInvalidBase64string,
  toBase64url
}
