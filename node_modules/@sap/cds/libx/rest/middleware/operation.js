const cds = require('../../_runtime/cds')
const getError = require('../../_runtime/common/error')

const { checkStatic } = require('../../_runtime/cds-services/util/assert')
const { Readable } = require('node:stream')

// REVISIT: strict or relaxed type checkers?
const typeCheckers = require('../../common/assert/type-strict')
const streaming = require('../../common/utils/streaming')

// REVISIT: use i18n
const _enrichErrorDetails = (isPrimitive, error) => {
  const element = error.target ? ` '${error.target}' ` : ' '
  const typeDetails = isPrimitive ? '.' : ` according to type definition '${error.type}'.`
  const value = typeof error.value === 'string' ? `'${error.value}'` : error.value
  if (element && element.match(/\w/)) return `Value ${value} of element${element}is invalid${typeDetails}`
  return `Value ${value} is invalid${typeDetails}`
}

// REVISIT: use i18n
const _getTypeError = (operation, type, errorDetails) => {
  const typeErrors = errorDetails.map(error => _enrichErrorDetails(cds.builtin.types[type], error))
  const msg = `Failed to validate return value ${type ? `of type '${type}' ` : ''}for custom ${operation.kind} '${
    operation.name
  }': ${typeErrors.join(' ')}`
  return getError(msg)
}

const _validateReturnType = (operation, data) => {
  // array of or single return type
  // in case of modeled return type: { type: 'bookModel.Books', _type: csnDefinition }
  // in case of inline return type: { elements: ... } and no explicit name of return type
  const returnType = operation.returns.items ? operation.returns.items : operation.returns

  if (typeof data === 'undefined') return true
  if (returnType['@open']) return true

  let checkResult

  // .type of action/function behaves different to .type of other csn elements
  // Return type contains primitives
  const _type = typeof returnType._type === 'object' ? returnType.__proto__._type : returnType._type // REVISIT: super dirty hack for compiler's to.edmx polluting the csn definitions with ._type -> please use Symbols instead
  const typeChecker = typeCheckers[_type] // IMPORTANT: use ._type
  if (typeChecker) {
    const array = Array.isArray(data) ? data : [data]
    checkResult = array.filter(value => !typeChecker(value)).map(value => ({ type: _type, value }))
  } else {
    if (typeof data !== 'object') {
      throw new Error(
        `Invalid scalar value ${typeof data === 'string' ? `"${data}"` : data} for return type "${returnType.type}"`
      )
    }

    // Only check complex objects, ignore non-modelled data
    data = (Array.isArray(data) ? data : [data]).filter(entry => typeof entry === 'object' && !Array.isArray(entry))

    // Determine entity from bound or unbound action/function
    const returnTypeCsnDefinition = returnType._type || returnType

    // REVISIT: remove exception with cds^6
    // mtx returns object instead of string (as in modell) -> skip validation
    if (returnTypeCsnDefinition.type !== 'cds.String') {
      checkResult = checkStatic(returnTypeCsnDefinition, data, true)
    }
  }

  if (checkResult && checkResult.length !== 0) {
    throw _getTypeError(operation, returnType.type, checkResult)
  }

  return true
}

module.exports = adapter => {
  const { service } = adapter

  return async function operation(req, res) {
    const { _query: query, _operation: operation, _data: data, _params: params } = req
    const request = adapter.request4(
      Object.assign(
        query // REVISIT: when is a query given, and when not? -> bound vs unbound? -> obsolete with req.subject? -> deprecated?
          ? { event: operation.name, query } // REVISIT: why don't we need a similar .replace as below here?
          : { event: operation.name.replace(`${service.definition.name}.`, '') }, // REVISIT: why is this .replace needed?
        { data, params, req, res } // REVISIT: req and res are not part of the public API !!!
      )
    )

    let result = await service.dispatch(request)

    if (!operation.returns || result == null) return { status: 204 }

    const _isStream = result instanceof Readable || (operation.returns._type === 'cds.LargeBinary' && 'value' in result)
    if (_isStream) {
      const stream = streaming.getReadable(result)
      if (!stream) {
        if (res.statusCode > 200) return res.end()
        return res.sendStatus(204)
      }

      const { mimetype, filename, disposition } = streaming.collectStreamMetadata(result, operation, query)
      streaming.validateMimetypeIsAcceptedOrThrow(req.headers, mimetype)

      if (mimetype && !res.get('Content-Type')) res.set('Content-Type', mimetype)

      if (filename && !res.get('Content-Disposition'))
        res.set('Content-Disposition', `${disposition}; filename="${filename}"`)
      // NOTE: We should NOT use encodeURIComponent here, as it is not needed for the filename in the Content-Disposition header
      //       and it would break the filename in the header if it contains special characters like
      //       e.g. German umlauts (ä, ö, ü) or spaces
      //       See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition

      return stream.pipe(res) && {} // REVISIT: strange caller expects this
    }

    // REVISIT: do not use from old rest adapter
    // REVISIT: new impl should return instead of throwing to avoid try catch
    _validateReturnType(operation, result)

    // set content-type header to text/plain for returned primitive data types, except for boolean
    const returnType = operation.returns._type
    if (
      cds.builtin.types[returnType] &&
      !operation.returns.items &&
      returnType !== 'cds.Boolean' &&
      !res.get('content-type')
    ) {
      res.set('Content-Type', 'text/plain')
    }

    // REVISIT: Still needed with cds-mtxs?
    // mtx compat, modeled as string but object returned
    if (operation.returns._type === 'cds.String' && typeof result === 'object') {
      res.set('Content-Type', 'application/json')
    }

    // REVISIT: still needed? // REVISIT: indeed!
    if (!operation.returns.items && Array.isArray(result)) result = result[0]

    if (result === undefined) return { status: 204 }

    return { result }
  }
}
