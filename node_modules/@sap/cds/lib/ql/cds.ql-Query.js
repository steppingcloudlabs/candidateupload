const { AsyncResource } = require('async_hooks')
const cds = require('../index')

const cloned = from => from.ref ? { ...from, ref:[...from.ref] } : { ...from }
const cached = {}


class Query {

  /** @private */
  static init () {
    const self = this, kind = self.name
    Object.defineProperty (this.prototype, 'kind', {value:kind})
    Object.defineProperty (this, 'name', {value:'cds.ql'})
    return Object.assign (function chimera (x,...etc) {
      if (!new.target) return self.call (x,...etc)
      let q = new self; if (x) q[kind] = x
      return q
    }, this.API)
  }

  /** @private to be implemented in subclassed*/
  static call() {}

  /** @private */
  get _(){ return this[this.kind] }


  /**
   * The kind of query, as in CQN's SELECT, INSERT, UPDATE, DELETE, CREATE, DROP.
   */
  get kind() { return this.constructor.name }


  /**
   * Note to self: We can't use .as (alias) as that would conflict with
   * sub selects in columns, which in turn may has aliases in .as.
   */
  alias (a) {
    this._target_ref.as = a
    return this
  }

  /** Creates a derived instance that initially inherits all properties. */
  clone (_) {
    const kind = this.kind || Object.keys(this)[0]
    return {__proto__:this, [kind]: {__proto__:this[kind],..._} }
  }

  flat (q=this) {
    let x = q.kind || Object.keys(q)[0], y = q[x]
    let protos = [y]; for (let o=y; o.__proto__;) protos.push (o = o.__proto__)
    q[x] = Object.assign ({}, ...protos.reverse())
    if (y.columns) for (let c of y.columns) if (c.SELECT) (this||Query.prototype).flat(c)
    return q
  }

  /** Binds this query to be executed with the given service */
  bind (srv) {
    // TODO: resolve target from srv.entities -> but better do that in .from
    return Object.defineProperty (this,'_srv',{ value:srv, configurable:true, writable:true })
  }

  /** Turns all queries into Thenables which execute with primary db by default */
  get then() {
    const srv = this._srv || cds.db || cds.error `Can't execute query as no primary database is connected.`
    const q = new AsyncResource('await cds.query')
    return (r,e) => q.runInAsyncScope (srv.run, srv, this).then (r,e)
  }

  /** @private */ get _target_ref() { return this._.from } // overridden in subclasses
  /** @private */ set _target(t) { this._set('_target', t.ref ? {name:t.ref[0]} : t) }

  /**
   * @param {string | Function | object} t - the target
   * @param {unknown[]} etc - additional arguments
   * @returns {typeof this._target | import('@sap/cds').ref}
   * @private
  **/
  _target4 (t,...etc) {
    switch (typeof t) {
      case 'string': {
        // NOTE: even though this._target will be {name:ref[0]} this returns the parsed {ref}
        // NOTE: we need to clone cached refs, as they might get modified afterwards
        return this._target = cloned (cached[t] ??= cds.parse.path(t))
      }
      case 'function':  // fallthrough for classes generated by cds-typer. Will end up in t.name subcase
      case 'object': {
        if (t.raw) return this._target = !etc.length ? this._target4(t[0]) : cds.parse.path(t,...etc)
        if (t.name) return {ref:[ (this._target = t).name ]}
        if (t.ref || t.SELECT || t.SET) return this._target = t
      }
    }
    throw this._expected `${{target:t}} to be an entity path string, a CSN definition, a {ref}, a {SELECT}, a {SET}, or a class representing an entity definition`
  }

  /** @private */ _expected (...args) {
    return cds.error.expected (...args)
  }

  /** @private */ _assign (...aspects) {
    Object.assign (this._, ...aspects)
    return this
  }

  /** @private */ _add (property, values) {
    const {_} = this, pd = Reflect.getOwnPropertyDescriptor (_,property)
    _[property] = !pd?.value ? values : [ ...pd.value, ...values ]
    return this
  }

  /** @private */ _set (property, value) {
    return Object.defineProperty (this, property, { value, configurable:true, writable:true })
  }

  valueOf (prelude = this.kind) {
    return `${prelude} ${_name(this._target.name)} `
  }

  /**
   * Returns the inferred query's source, which is the entity referred
   * to in SELECT.from, INSERT.into, UPDATE.entity, or DELETE.from,
   * or a sub query specified in SELECT.from, INSERT.into,
   */
  get source() {
    const m = this._srv?.model || cds.context?.model || cds.model
    return cds.infer (this, m?.definitions, 'get source')
  }
  set source(t) { this._set('source',t) }

  /**
   * Returns the inferred query's target, which is the entity referred
   * to in SELECT.from, INSERT.into, UPDATE.entity, or DELETE.from.
   * In case of a sub query specified in SELECT.from, INSERT.into,
   * returns the target of the sub query, recursively.
   */
  get target() {
    if (this._target instanceof cds.entity) return super.target = this._target
    const m = this._srv?.model || cds.context?.model || cds.model
    return this.target = cds.infer (this, m?.definitions)
  }
  set target(t) { this._set('target',t) }

  /** @deprecated use .kind instead */
  get cmd() { return this.kind }
}

const _name = cds.env.sql.names === 'quoted' ? n =>`"${n}"` : n => n.replace(/[.:]/g,'_')

module.exports = Query
