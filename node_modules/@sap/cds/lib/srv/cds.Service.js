//////////////////////////////////////////////////////////////
//
//  PLEASE DO NOT RUN prettier ON THIS FILE
//
//////////////////////////////////////////////////////////////

const cds = require('../index')
const EventHandlers = require('./srv-handlers')


/**
 * Private base class which contains all model & reflection-related APIs.
 */
class ModeledService {

  /**
   * Constructs a new instance. Argument name can be omitted if the model contains only one service.
   * @param {string} [name] - the name of the service
   * @param {object} [model] - the CSN model
   * @param {object} [options] - additional options
   * @param {string} [options.kind] - the kind of the service
   * @param {function} [options.impl] - the implementation function
   */
  constructor (model, name, options={}) {
    this.name = name || new.target.name
    this.options = options
    if (options.kind) this.kind = options.kind // shortcut
    if (model) this.model = model
  }

  /** @param {import('../core/linked-csn').LinkedCSN} csn */
  set model (csn) {
    super.model = csn ? cds.compile.for.nodejs(csn) : undefined
  }

  /**
   * Lazy get the service definition from this.model
   * @type import('../core/classes').service
   */
  get definition() {
    const defs = this.model?.definitions; if (!defs) return super.definition = undefined
    return super.definition = defs[this.options.service] || defs[this.name]
  }

  /** The namespace always is the service definition name */
  get namespace()  {
    return super.namespace  = this.definition?.name
    || this.model?.namespace
    || !this.isDatabaseService && !/\W/.test(this.name) && this.name
    || undefined
  }

  // Reflection methods
  get entities()   { return super.entities = this.reflect (d => d.kind === 'entity') }
  get events()     { return super.events   = this.reflect (d => d.kind === 'event') }
  get types()      { return super.types    = this.reflect (d => !d.kind || d.kind === 'type') }
  get actions()    { return super.actions  = this.reflect (d => d.kind === 'action' || d.kind === 'function') }
  /** @deprecated */ get operations() { return this.actions } // compatibility
  reflect(filter) { return this.model?.childrenOf (this.namespace, filter) || [] }
}


class Service extends ModeledService {

  constructor (name, model, options) {
    if (typeof name === 'object') {
      [ model, options ] = [ name, model ]
      let srv = cds.linked(model).services[0] || cds.error.expected `${{model}} passed as first argument to be a CSN with a single service definition`
      name = srv.name
    }
    super (model, name, options)
  }

  /**
   * Empty init() function to allow custom code to always call super.init()
   * without having to care for if .init() exists.
  */
 init(){ return this }

 // Event Handlers Registration API
  handlers = new EventHandlers
  prepend (fn)      { return this.handlers.prepend.call (this,fn) }
  before  (...args) { return this.handlers.register (this, 'before', ...args) }
  on      (...args) { return this.handlers.register (this, 'on',     ...args) }
  after   (...args) { return this.handlers.register (this, 'after',  ...args) }
  reject  (e, path) { return this.handlers.register (this, '_initial', e, path,
    r => r.reject (405, `Event "${r.event}" not allowed for entity "${r.path}".`)
  )}

  // Event Dispatching API
  dispatch (req) {
    const { dispatch } = require('./srv-dispatch')
    return (Service.prototype.dispatch = dispatch) .call (this,req)
  }

  handle (req) {
    const { handle } = require('./srv-dispatch')
    return (Service.prototype.handle = handle) .call (this,req)
  }

  tx (...args) {
    return (Service.prototype.tx = require('./srv-tx')) .call (this,...args)
  }

  /**
   * @deprecated Flag to control whether this service is extensible.
   * Can be overridden by subclasses.
   */
  get isExtensible() { // REVISIT: can we eliminate this?
    return this.model === cds.model && !this.name?.startsWith('cds.xt.')
  }

  /** @deprecated */ get _handlers() { return this.handlers }
}

/** @deprecated */ Service.prototype.transaction = function(...args) { return this.tx(...args) }
/** @deprecated */ Service.prototype._implicit_next = cds.env.features.implicit_next

Service._is_service_class = true              //> for factory

//--------------------------------------------------------------------------
// EXPERIMENTAL: It is not decided yet, whether we should keep the stuff below
// => Please do not use anywhere!
Service.prototype.onSucceeded = function (...args) { return _req_on (this, 'succeeded', ...args) }
Service.prototype.onFailed = function (...args) { return _req_on (this, 'failed', ...args) }
const _req_on = (srv, succeeded_or_failed, event, path, handler) => {
  if (!handler) [path,handler] = [undefined,path]
  return srv.before (event,path, req => req.on(succeeded_or_failed,handler))
}

module.exports = Service
