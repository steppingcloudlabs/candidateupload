//////////////////////////////////////////////////////////////
//
//  PLEASE DO NOT RUN prettier ON THIS FILE
//
//////////////////////////////////////////////////////////////

const cds = require('../index'), { Event, Request } = cds
const Service = require('./cds.Service')

const is_rest = x => x && typeof x === 'string' && x[0] === '/'
const is_query = x => x && x.bind || is_array(x) && !x.raw
const is_array = (x) => Array.isArray(x) && !x.raw
const is_object = (x) => typeof x === 'object'

class ServiceClient extends Service {

  constructor (...args) {
    super(...args)
    this.decorate()
  }

  /**
   * Messaging API to emit asynchronous event messages, i.e. instances of `cds.Event`.
   */
  emit (event, data, headers) {
    const eve = event instanceof Event ? event : new Event (
      is_object(event) ? event
      : { event, data, headers }
    )
    return this.dispatch (eve)
  }

  /**
   * REST-style API to send synchronous requests...
   */
  send (method, path, data, headers) {
    const req = method instanceof Request ? method : new Request (
      is_object(method) ? method :
      is_object(path) ? path.is_linked ? { method, entity:path, data, headers } : { method, data:path, headers:data }
      : { method, path, data, headers }
    )
    return this.dispatch (req)
  }
  get    (...args) { return is_rest(args[0]) ? this.send('GET',   ...args) : this.read   (...args) }
  put    (...args) { return is_rest(args[0]) ? this.send('PUT',   ...args) : this.update (...args) }
  post   (...args) { return is_rest(args[0]) ? this.send('POST',  ...args) : this.create (...args) }
  patch  (...args) { return is_rest(args[0]) ? this.send('PATCH', ...args) : this.update (...args) }
  delete (...args) { return is_rest(args[0]) ? this.send('DELETE',...args) : DELETE.from (...args).bind(this) }

  /**
   * Querying API to send synchronous requests...
   */
  run (query, data) {
    if (query.raw) [ query, data ] = [ cds.ql (...arguments) ]
    else if (typeof query === 'function') {
      const fn = query; if (this.context) return fn(this)     // if this is a tx -> run fn with this
      const ctx = cds.context, tx = ctx?.tx                   // is there an (open) outer tx? ...
      if (!tx || tx._done === 'committed') return this.tx(fn) // no -> run fn with root tx
      if (tx._done !== 'rolled back') return fn(this.tx(ctx)) // yes -> run fn with nested tx
      else throw this.tx._is_done (tx._done)                  // throw if outer tx was rolled back
    }
    const req = new Request ({ query, data })
    return this.dispatch (req)
  }
  read   (...args) { return is_query(args[0]) ? this.run(...args) : SELECT.read(...args).bind(this) }
  insert (...args) { return INSERT(...args).bind(this) }
  create (...args) { return INSERT.into(...args).bind(this) }
  update (...args) { return UPDATE.entity(...args).bind(this) }
  upsert (...args) { return UPSERT(...args).bind(this) }
  exists (...args) { return SELECT.one([1]).from(...args).bind(this) }

  /**
   * Streaming API variant of .run(). Subclasses should override this to support real streaming.
   * The default implementation doesn't stream, but simply invokes the callback on each row.
   * The callback function is invoked with (row, index).
   */
  foreach (query, data, callback) {
    if (!callback)  [ data, callback ] = [ undefined, data ]
    return this.run (query, data) .then (rows => rows.forEach(callback) || rows)
  }

  /**
   * Subclasses may override this to free resources when
   * tenants offboard or the service is disposed.
   */
  disconnect (tenant) { // eslint-disable-line no-unused-vars
    // if (this === cds.db) { //> REVISIT: should go into DatabaseService
    //   if (!tenant) cds.db = undefined
    //   else if (this.dbcs) this.dbcs.delete[tenant] // This code is obviously wrong and never tested -> is that required ?!?
    // }
    // delete cds.services[this.name] // REVISIT: this is in contrast to some tests
  }
}
ServiceClient.prototype.decorate = require('./srv-methods')

module.exports = ServiceClient
