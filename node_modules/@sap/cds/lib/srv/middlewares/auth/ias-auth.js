const cds = require('../../../index.js')
const LOG = cds.log('auth')

let xssec = require('./xssec')


// REVISIT: Why do we need to know and do that?
const KNOWN_CLAIMS = Object.values({
  /*
   * JWT claims (https://datatracker.ietf.org/doc/html/rfc7519#section-4)
   */
  ISSUER: 'iss',
  SUBJECT: 'sub',
  AUDIENCE: 'aud',
  EXPIRATION_TIME: 'exp',
  NOT_BEFORE: 'nbf',
  ISSUED_AT: 'iat',
  JWT_ID: 'jti',
  /*
   * TokenClaims (com.sap.cloud.security.token.TokenClaims)
   */
  // ISSUER: "iss", //> already in JWT claims
  IAS_ISSUER: 'ias_iss',
  // EXPIRATION: "exp", //> already in JWT claims
  // AUDIENCE: "aud", //> already in JWT claims
  // NOT_BEFORE: "nbf", //> already in JWT claims
  // SUBJECT: "sub", //> already in JWT claims
  // USER_NAME: 'user_name', //> do not exclude
  // GIVEN_NAME: 'given_name', //> do not exclude
  // FAMILY_NAME: 'family_name', //> do not exclude
  // EMAIL: 'email', //> do not exclude
  SAP_GLOBAL_SCIM_ID: 'scim_id',
  SAP_GLOBAL_USER_ID: 'user_uuid', //> exclude for now
  SAP_GLOBAL_ZONE_ID: 'zone_uuid',
  // GROUPS: 'groups', //> do not exclude
  AUTHORIZATION_PARTY: 'azp',
  CNF: 'cnf',
  CNF_X5T: 'x5t#S256',
  // own
  APP_TENANT_ID: 'app_tid'
})


module.exports = function ias_auth(config) {
  // cds.env.requires.auth.known_claims is not an official config!
  const { kind, credentials, known_claims = KNOWN_CLAIMS } = config
  const skipped_attrs = known_claims.reduce((a,x) => { a[x] = 1; return a }, {})

  if (!credentials) throw new Error(
    `Authentication kind "${kind}" configured, but no IAS instance bound to application. ` +
    'Either bind an IAS instance, or switch to an authentication kind that does not require a binding.'
  )

  function getUser(tokenInfo) {
    const payload = tokenInfo.getPayload()

    const clientid = tokenInfo.getClientId()
    if (clientid === payload.sub) { //> grant_type === client_credentials or x509
      const roles = { 'system-user': 1 }
      if (Array.isArray(payload.ias_apis)) payload.ias_apis.forEach(r => (roles[r] = 1))
      if (clientid === credentials.clientid) roles['internal-user'] = 1
      else delete roles['internal-user']
      return new cds.User({ id: 'system', roles, tokenInfo })
    }

    // add all unknown attributes to req.user.attr in order to keep public API small
    const attr = {}
    for (const key in payload) {
      if (key in skipped_attrs) continue // REVISIT: Why do we need to do that?
      else attr[key] = payload[key]
    }

    // REVISIT: just don't such things, please! -> We're just piling up tech dept through tons of unoficcial long tail APIs like that!
    // REVISIT: looks like wrong direction to me, btw
    // same api as xsuaa-auth for easier migration
    if (attr.user_name) attr.logonName = attr.user_name
    if (attr.given_name) attr.givenName = attr.given_name
    if (attr.family_name) attr.familyName = attr.family_name

    return new cds.User({ id: payload.sub, attr, tokenInfo })
  }

  // NOTE: Use named function for better stack traces... for the actual middleware, of course, not that much for the factory!

  if (xssec.v3 && cds.env.features.xssec_compat !== true) { // no official flag!
    let { createSecurityContext, IdentityService, errors: { ValidationError } } = xssec
    const authService = new IdentityService(credentials)

    return async function ias_auth (req, _, next) {
      if (!req.headers.authorization) return next()
      try {
        const secContext = await createSecurityContext(authService, { req })
        const tokenInfo = secContext.token
        const ctx = cds.context
        ctx.user = getUser(tokenInfo)
        ctx.tenant = tokenInfo.getZoneId()
        req.authInfo = secContext //> compat req.authInfo
      } catch(e) {
        if (e instanceof ValidationError) {
          LOG.warn("Unauthenticated request: ", e);
          return next(401)
        }
        LOG.error("Error while authenticating user: ", e);
        return next(500)
      }
      next()
    }
  } else { // TODO: Remove with cds 9
    xssec = xssec.v3 || xssec
    return function ias_auth (req, _, next) {
      if (!req.headers.authorization) return next()
      const token = req.headers.authorization.slice(7) // skip /^bearer /
        xssec.createSecurityContext(token, credentials, 'IAS', function (err, securityContext, tokenInfo) {

          if (err) LOG.warn('User could not be authenticated due to error:', err)
          if (!securityContext) {
            return next(401)
          }
          else req.authInfo = securityContext //> compat req.authInfo

          const ctx = cds.context
          ctx.user = getUser(tokenInfo)
          ctx.tenant = tokenInfo.getZoneId()
          next()
        })
    }
  }
}
