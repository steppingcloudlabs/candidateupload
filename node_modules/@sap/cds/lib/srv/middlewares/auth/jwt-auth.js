const cds = require('../../../index.js')
const LOG = cds.log('auth')

let xssec = require('./xssec')

module.exports = function jwt_auth(config) {
  const { kind, credentials } = config

  if (!credentials) throw new Error(
    `Authentication kind "${kind}" configured, but no XSUAA instance bound to application. ` +
    'Either bind an XSUAA instance, or switch to an authentication kind that does not require a binding.'
  )

  const xsappname = credentials.xsappname.length + 1

  function getUser(tokenInfo) {
    const payload = tokenInfo.getPayload()

    let id = payload.user_name

    const roles = {}
    for (let scope of payload.scope) {
      let role = scope.slice(xsappname) // Roles = scope names w/o xsappname...
      if (role in { 'internal-user': 1, 'system-user': 1 }) continue  // Disallow setting system roles from external
      else roles[role] = 1
    }

    // Add system roles in case of client credentials flow
    if (payload.grant_type in { client_credentials: 1, client_x509: 1 }) {
      id = 'system'
      roles['system-user'] = 1
      if (tokenInfo.getClientId() === credentials.clientid) roles['internal-user'] = 1
    }

    const attr = { ... payload['xs.user.attributes'] }
    if (kind === 'xsuaa') {
      attr.logonName = payload.user_name
      attr.givenName = payload.given_name
      attr.familyName = payload.family_name
      attr.email = payload.email
    }

    return new cds.User({ id, roles, attr, tokenInfo })
  }
  if (xssec.v3 && cds.env.features.xssec_compat !== true) { // no official flag!
    const { createSecurityContext, XsuaaService, errors: { ValidationError } } = xssec
    const authService = new XsuaaService(credentials)

      return async function jwt_auth(req, _, next) {
        if (!req.headers.authorization) return next()

        try {
          const secContext = await createSecurityContext(authService, { req })
          const tokenInfo = secContext.token
          const ctx = cds.context
          ctx.user = getUser(tokenInfo)
          ctx.tenant = tokenInfo.getZoneId()
          req.authInfo = secContext //> compat req.authInfo
        } catch(e) {
          if(e instanceof ValidationError) {
            LOG.warn("Unauthenticated request: ", e);
            return next(401)
          }
          LOG.error("Error while authenticating user: ", e);
          return next(500)
        }

        next()
      }

  } else {
    xssec = xssec.v3 || xssec

    // NOTE: Use named function for better stack traces... for the actual middleware, of course, not that much for the factory!
      return function jwt_auth (req, _, next) {
        if (!req.headers.authorization) return next()
        const token = req.headers.authorization.slice(7) // skip /^bearer /
          xssec.createSecurityContext(token, credentials, function (err, securityContext, tokenInfo) {

            if (err) LOG.warn('User could not be authenticated due to error:', err)
            if (!securityContext) return next(401)
            else req.authInfo = securityContext //> compat req.authInfo

            const ctx = cds.context
            ctx.user = getUser(tokenInfo)
            ctx.tenant = tokenInfo.getZoneId()
            next()
          })
      }
  }
}
